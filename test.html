<!DOCTYPE html>
<html>
<head>
    <title>javascript Test</title>
</head>
<body>
    <h1>Cheatsheet</h1>
	<p>alle Cheatsheet Ausgaben sind in der Console >.<</p>
    <script>
	
<!-- --------------------------------------------------------------------------------------- -->
<!-- -------------------------------------- Javascript -------------------------------------- -->
<!-- --------------------------------------------------------------------------------------- -->
	
	/* ----- Datentypen ----- */
		//bei Pruefung ergibt false wenn Value = 0, "", null, undefined, NaN
		//Datentypen: undefined, null, boolean, string, symbol, bigint, number, object
		let x; //mit let lassen sich variablen danach aendern, ohne Wert deklarieren = undefined
		let counter = 0;
		const y = null; //mit constanten lassen sich variablen nicht mehr aendern, values in Objekten/Arrays sind änderbar
		x = 5.23 + 3; //Number
		x++; //x + 1
		x = "Markus mit\"escape Character sowie \n newline und \t tab" + " weiterer String"; //String, im String mit \ Escapen
		x = `per hochkommata(backticks) \` sowie ${y} lassen sich Variable in Strings einbinden sowie mehrzeilie (multiline) Strings` //Template Literals
		x = null; //absence of Value
		x = undefined; //value does not exist
		x = Symbol("id"); //Symbol
		const numberParse = +"100"; const numberParse2 = parseInt("100"); //Kurzform
		const testBool = true; //Boolean
		testBool2 = Boolean(x); //wenn es einen Wert in x gibt ist es true, Variable ohne const ist im Scope lokal, mit const/let ist global
		const testObject = {_type:"Fiat", _color:"white", engineNoise() {console.log("brumm")}, get Type () {return this._type}, set Type(str){this._type = str},}; //Object, Arrow Functions in Objekten binden den this Befehl an die Funktion, property names = keys
		const testArray = ["testarray 0", "testarray 1", "testarray 2"]; //Array, push(), pop(), shift() wenn Array an Funktion mit mehreren Argumenten uerbgeben werden soll Spread Syntax: ...testArray
		const nestedObjectArray = [{color: "blue", cost:1000}, {color: "green", cost:500}]; //Zugriff: nestedObjectArray[0].color
		console.log(typeof x); //typeof Operator gibt den Datentyp aus
		z = x || "Wert wenn x = false";
		const {_color} = testObject; //per Destructured Assignment einen Wert aus einem Object extrahieren = const color = testObject.color
		const [destructA=5, destructB=5, destructC=5] = [0, 1]; //destructA = 0, destructB = 1, destructC = 5 => destrukturierende Zuweisung, Daten aus Arrays der Reihe nach extrahieren



	/* ----- Properties + Methods + Built-in Objects ----- */
		//jeder Datentyp / jedes Objekt hat eigene Properties und Methoden (= Funktionen in Objekten)
		console.log("Hello".length); //String Datentyp mit .length Propertie
		console.log("Hello".toUpperCase()); //String Datentyp mit toUpperCase() Methode
		console.log("   Remove Whitespace   ".trim());
		console.log(Math.floor(Math.random()*100)); //Object Math mit Methode random()
		console.log(Number.isInteger(123));
		console.log("String 1 " + "String 2"); //String mit + = String Concatenation
		testArray.forEach(element => console.log("for each in testArray: " + element)); //Iterator Methode fuer Arrays, geht jedes Element durch
		const neuestestArray = testArray.map(element => {return "neues " + element}); //geht wie forEach jedes Element durch und erstellt ein neues Array, mit testArray.map((row, index, objekt) => {} koennen mehr Informationen rausgeholt werden
		const neuestestArray2 = testArray.filter(element => {return !element.includes("1")}); //wie map() nur dass man bestimmte Werte rausfiltern kann
		const neuestestArray3 = testArray.findIndex(element => {return element.charAt(0)==="t"}); //findet das erste element in einem array dass einer bedingung entspricht, wenn nichts gefunden ist die ausgabe -1
		const neuestestArray4 = nestedObjectArray.find(x => x.color === "green"); console.log(neuestestArray4); //findet nach Objekte Werte in Arrays
		delete testObject._color; //Propertys von Objekten entfernen
		testObject.Type = "BMW"; //eigenen Object Setter verwenden
		console.log(testObject.Type); //eigenen Object Getter verwenden
		const testObjectKeys = Object.keys(testObject); //gibt alle Keys von einem Objekt in ein Array
		const testObjectEntries = Object.entries(testObject); //gibt alle Key-Value Paare in einzelnen Arrays aus
		const lastLetterOfString = "String"["String".length - 1]; //sollte "g" sein
		const onlyValues = Object.values(testObject);
		const objectToArray = Object.entries(testObject);
		

	/* ----- Statements, Loops, Arrays ----- */
	//Vergleiche mit: <,>, <=, >=, ===, !==, &&, ||
		 
		if (testBool) {console.log('statement 1')} else if (testBool) {'statement 2'} else {'statement 3'}
		switch (testArray) {case true: console.log('true'); break; case "Markus": console.log("Markus"); break; default: console.log("Default"); break;}
		for (let counter=0; counter<testArray.length; counter++) {console.log(testArray[counter])};
		while (counter < 5) {console.log("while: " + counter); counter++;} //laeuft nur wenn die Bedingung erfuellt ist
		do {console.log("do while"); break} while (0<1); //laeuft auf jeden Fall einmal durch
		for (let element in testObject) {console.log("for element in testObject: " + element)};



	/* ----- Kurzschreibweisen / Shorthand Techniques ----- */
		testBool ? console.log('statement 1 wenn testbool true') : console.log('statement 3 wenn testbool false'); //Ternary Operator = if/else in Kurzschreibweise
		const nco = undefined ?? "Default"; //Nullish Coalescing Operator, wenn der Wert links von den ?? undefined oder null ist wird die Default Value von rechts verwendet
		const lncafunc = (var1, var2) => {var2 ??= "default value"; return var1 + var2;}; console.log(lncafunc("leer ",)); //Logical nullish assignment, default value setzen
		let sce = "" || "Default"; //Short-Circuit Evaluation, wenn der Wert links von || undefined, null, "" oder 0 ist wird der Default Value von rechts verwendet
		let test = null || undefined || "Value" //Short-Circuit Evaluation als Kaskade;
		console.log("kaskade: " + test)
		for (let i of testArray) {console.log("Kurzschreibweise for mit of: " + i)}; for (let i in testArray) {console.log("Kurzschreibweise for mit in: " + i)};



	/* ----- Funktionen ---- */
		//wenn eine Funktion an eine andere Funktion uebergeben wird = higher-order function/callback function
		function greetings(name="User") {console.log("Hello " + name + "!");} greetings("Markus");
		const functionExpression = function(x) {console.log(x)};
		const arrowFunction = (width=3, height=4) => {let area=width*height; return area;}; //mit Default Values
		const arrowFunction2 = day => day === "Monday" ? true:false; //Concise body
		const arrowFunction3 = () => {};
		const arrowFunction4 = uebergabe => uebergabe + uebergabe; //return ist hier schon inkludiert
		const arrowFunction5 = uebergabe => (uebergabe + "mehr"); //Implicit Return, return ist inkludiert
		const monsterFactory = (name, weapon) => {return {name, weapon}}; //destructuring, statt name: name

<!-- --------------------------------------------------------------------------------------- -->
<!-- -------------------------------------- Typescript -------------------------------------- -->
<!-- --------------------------------------------------------------------------------------- -->

	//codecademy commands: tsc, ls, node index.js

	/* ----- Datentypen ----- */
		//boolean, number, null, string, undefined, any
		//prueft wie eine Variable initert wurde und erlaubt dann nur noch diesen Datentyp inkl. deren Methoden, außer die variable wurde als any / leer initiert
			//let mustBeAString : string; //Variable Type Annotations moeglich
	 
	 /* ----- tsconfig.json ----- */
		 //liegt im root Verzeichnis, Beispieldatei: es2017 = EmmaScript 2017 Standard, ermöglicht die CMD "tsc"
			//	{
			//	  "compilerOptions": {
			//	    "target": "es2017",
			//	    "module": "commonjs",
			//	    "strictNullChecks": true
			//	  },
			//	  "include": ["**/*.ts"]
			//	}
	 
<!-- --------------------------------------------------------------------------------------- -->
<!-- -------------------------------------- React -------------------------------------- -->
<!-- --------------------------------------------------------------------------------------- -->

	/* ---- JSX ----
	-------- Allgemeines --------
		JSX = eine Erweiterung zu js, wird kompiliert und kann ueberall verwendet werden
		hat Attribute wie bei HTML Elementen, mit <h1 Attribut=''></h1>
		wenn jsx Expression groesser als 1 Zeile ist muss die Expression in Klammern, z.B.: const h1 = (<h1>Hello world</h1>)
		muss 1 Element haben dass alle anderen umfasst (z.B. keine zwei Divs untereinander)
		statt CSS class muss className verwendet werden (wird als class gerendert)
		mit {} kann javascript in jsx verwendet werden
			- bei <h1 style={{color:'red'}}></h1> wird erst angegeben dass es sich um js handelt und danach das es um ein js object literal geht
		Kein if in JSX möglich
	
	
	-------- Ausgabe--------
		Render = ReactDOM.render(<h1></h1>, document.getElementById('app');
			- <h1> = das erste Argument in jsx (kann auch variable/function sein)
			- getElement = das zweite Argument, wo das HTML im HTML Document angehaengt werden soll, es muss im HTML eine ID mit dem Namen "app" geben
			- wenn 2x derselbe Render aufgerufen wird, wird das DOM element geupdated nicht angehaengt
		<ul>{age > 15 && <li>Brussels Sprouts</li>}</ul> //wenn True dann wird der rechte Wert gerendert sonst nicht
		const listItems = ['Home', 'Shop', 'About Me'].map((item, i) => <li key={i}>{item}</li>);

		ohne JSX: const greatestDivEver = <div>i am div</div>; => const greatestDivEver = React.createElement("div", null, "i am div");
	
	
	-------- Event Listener --------
		sind Attribute in JSX Elementen und beginnen immer mit onTypeofEvent = Function-Attribut-Value
		Attribut Value ist immer eine Function
		Eine Liste gibt es hier: https://reactjs.org/docs/events.html#supported-events
		onClick
		*/


	/* ---- Komponenten ----
	-------- Class Komponenten --------
		Deklaration: //Name muss mit grossen Buchstaben beginnen, muss render Methode enthalten, render muss return enthalten
			class Xxx extends React.Component {
				constructor(props){super(props);this.state = {date: new Date()}} //states sind nur intern, hier werden inital values definiert
				myFunction() {this.setState({date: 25})}
				render() {const xxx = 'xxx'; return(<h1>xxx {this.myFunction} {this.props.prop1}/h1>);}};
		Verwendung: <Xxx prop1="" prop2={2} prop3={[]}/>; //es koennen props uebergeben werden, props NIE innerhalb der Klasse ändern
		Ausgabe: ReactDOM.render(<Xxx prop1="" />, document.getElementById('app'));
		andere Klassen verwenden: import {AndereKlasse} from './AndereKlasse.js' //in {} wenn es sich um named exports handelt
		named export = export steht vor der Deklaration z.b. einer Variablen: export const xxx
		this.props.children = alles was zwischen openingn und end Tag steht z.B. <ClassKomp>Children</ClassKomp>, werden in Array ausgegeben
		Xxx.defaultProps = { text: 'yo' };
		this.setState() => callt automatisch .render()
	
	
	-------- Function Komponenten --------
		Deklaration: const Xxx = (props) => {return <h1>{props.prop1}</h1>}; //muessen jsx returnen
		Verwendung: wie Class Komponente
		Ausgabe: wie Class Komponente
		Hooks:
			- import {useState} from 'react'; const [currentValue, SetNewValue] = useState(["id":x]); //damit kann man dynamisch einer Variablen einen Wert zuweisen
				- SetNewValue((prev) => ({...prev, id: Date.now()})); //damit ändert man das currentValue auf den Value von vorher + das aktuelle Datum als ID
			- import {useEffect} from 'react'; const //useEffect wird bei jedem Render ausgeführt = wenn komponente hinzugefügt wird, wenn sich state/props ändern, wenn die komponente entfernt wird
				- useEffect(() => {document.title = `${name} Uebungsplatz`},[name]); //immer wenn sich beim State name was ändert wird der Effekt ausgeführt
				- useEffect(() => {alert("component rendered for the first time");return () => {alert("component is being removed from the DOM");};}, []); //Leeres Dependency Array als 2. Argument übergeben, damit Effekt nur beim ersten Render ausgeführt wird
	
	
	-------- PropTypes --------
		import PropTypes from 'prop-types'; //Value von PropTypes = Object
		//name = erwartetes prop, value= erwarteter Datentyp
		Klasse.propTypes = {message: PropTypes.string}; //bei Klassen
		FunctionComponent.propTypes = {message: PropTypes.string.isRequired} //bei Function Components
	
	
	-------- Lifecycle --------
		side effects = z.B. loading external Data with AJAX, manual DOM tweaking, global values, State Updates auf unmounted components... (alles was Bugs verursacht)
		Mounting = no side effects (constructor(), render()), allowed side effects (React updates DOM and refs, componentDidMount())
		Updating = no side effects (New props, setState(), forceUpdate(), render()), allowed side effects (React updates DOM and refs, componentDidUpdate())
		Unmounting = allowed side effects (componentWillUnmount())
	*/

    </script> 

<!-- --------------------------------------------------------------------------------------- -->
<!-- -------------------------------------- Testzeugs -------------------------------------- -->
<!-- --------------------------------------------------------------------------------------- -->

	<h1>Ab hier kein Cheatsheet sondern Testzeugs</h1>
	
	<style>
		h1 { color: green; border-left: 3px solid green; }
	</style>
	
	<script>
		function myFunction(x, y, z) {return x+y+z}
		var args = [0, 1, 2];
		var args2 = [3, 4, 5];
		console.log(myFunction(...args));
		//document.write(Date());

		testDaten = [{"code": "DEMOORACLE","isDefault": false},{"code": "DEV","isDefault": true},{"code": "AIL","isDefault": false},{"code": "PSLEASING","isDefault": false},{"code": "XLEASING","isDefault": false},{"code": "SKE","isDefault": false},{"code": "GSLEASE","isDefault": false},{"code": "MASTER","isDefault": false},{"code": "BRODSCHRANGEN","isDefault": false}];
		testDaten2 = [{"id": "name","title": "Name","type": "string","editable": false,"format": null,"searchable": true},{"id": "vorname","title": "Vorname","type": "string","editable": false,"format": null,"searchable": true},{"id": "zusatz","title": "Zusatz","type": "string","editable": false,"format": null,"searchable": true},{"id": "geburtsdatum","title": "Geburtsdatum","type": "date","editable": false,"format": null,"searchable": true},{"id": "rechtsform","title": "Rechtsform","type": "string","editable": false,"format": null,"searchable": true},{"id": "status","title": "Status","type": "string","editable": true,"format": null,"searchable": true}]


		//const neuestestArray4 = nestedObjectArray.find(x => x.color === "green"); console.log(neuestestArray4);
		console.log("++++++++++++++++++")
		console.log(Boolean(testDaten.find(domain => domain.isDefault === true)) ? testDaten.find(domain => domain.isDefault === true).code : "");
		console.log(testDaten2);

		const testDaten2map = testDaten2.map((a, b, c, d) => {
			console.log("a : ");console.log(a); //row
			console.log("b : ");console.log(b); //index
			console.log("c : ");console.log(c); //object
			console.log("d : ");console.log(d); //undefined
		});


	</script>
	
	<div>
		
	</div>
	
	
	<div>
		<div>
			<h1>Ein <abbr title="Cascading Style Sheets">CSS</abbr>-Beispiel</h1>
			<p>das CSS abbr erbt nur die Farbe und nicht den Border..</p>
		</div>
	</div>
	
</body>
</html>